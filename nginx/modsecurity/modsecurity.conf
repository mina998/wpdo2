# -- 规则引擎初始化 ----------------------------------------------

# 启用 ModSecurity,将其附加到每个事务。开始时仅使用检测模式,这样可以最大限度地减少安装后的中断。
# SecRuleEngine DetectionOnly
SecRuleEngine On


# -- 请求体处理 ---------------------------------------------------

# 允许 ModSecurity 访问请求体。如果不允许,ModSecurity 将无法看到任何 POST 参数,这会给攻击者留下巨大的安全漏洞。
SecRequestBodyAccess On


# 启用 XML 请求体解析器。在 xml content-type 的情况下初始化 XML 处理器。
SecRule REQUEST_HEADERS:Content-Type "^(?:application(?:/soap\+|/)|text/)xml" \
     "id:'200000',phase:1,t:none,t:lowercase,pass,nolog,ctl:requestBodyProcessor=XML"

# 启用 JSON 请求体解析器。在 JSON content-type 的情况下初始化 JSON 处理器;如果您的应用程序不使用 'application/json',请相应更改。
SecRule REQUEST_HEADERS:Content-Type "^application/json" \
     "id:'200001',phase:1,t:none,t:lowercase,pass,nolog,ctl:requestBodyProcessor=JSON"

# JSON 请求体解析器示例规则,用于更多子类型。如果要为 "+json" 子类型启用 JSON 处理器,请取消注释或调整此规则。
#SecRule REQUEST_HEADERS:Content-Type "^application/[a-z0-9.-]+[+]json" \
#     "id:'200006',phase:1,t:none,t:lowercase,pass,nolog,ctl:requestBodyProcessor=JSON"

# 我们接受缓冲的最大请求体大小。如果支持文件上传,则第一行给出的值必须与您愿意接受的最大文件一样大。第二个值指的是不包括文件的数据大小。您希望将该值保持在实际可行的最低水平。
SecRequestBodyLimit 52428800
SecRequestBodyNoFilesLimit 524288

# 当请求体大小超过配置限制时该怎么办。请注意,当 SecRuleEngine 设置为 DetectionOnly 模式时,此设置将自动设置为 ProcessPartial,以最大限度地减少初始部署 ModSecurity 时的中断。
SecRequestBodyLimitAction Reject

# 允许的 JSON 对象最大解析深度。您希望将此值保持在实际可行的最低水平。
SecRequestBodyJsonDepthLimit 512

# 每个请求允许的最大参数数。您希望将此值保持在实际可行的最低水平。该值应与规则 200007 中的值匹配。
SecArgumentsLimit 1000

# 如果设置了 SecArgumentsLimit,您可能希望拒绝任何仅部分解析的请求体。此规则中使用的值应与 SecArgumentsLimit 使用的值匹配。
SecRule &ARGS "@ge 1000" \
"id:'200007', phase:2,t:none,log,deny,status:400,msg:'Failed to fully parse request body due to large argument count',severity:2"

# 验证我们是否正确处理了请求体。根据经验,当无法处理请求体时,您应该拒绝请求(在阻止模式下部署时)或记录高严重性警报(在仅检测模式下部署时)。
SecRule REQBODY_ERROR "!@eq 0" \
"id:'200002', phase:2,t:none,log,deny,status:400,msg:'Failed to parse request body.',logdata:'%{reqbody_error_msg}',severity:2"

# 默认情况下,对 multipart/form-data 请求体采用严格验证。如果下面的规则对您的环境来说过于严格,请考虑将其更改为仅检测模式。建议不要完全删除它。
SecRule MULTIPART_STRICT_ERROR "!@eq 0" \
"id:'200003',phase:2,t:none,log,deny,status:400, \
msg:'Multipart request body failed strict validation: \
PE %{REQBODY_PROCESSOR_ERROR}, \
BQ %{MULTIPART_BOUNDARY_QUOTED}, \
BW %{MULTIPART_BOUNDARY_WHITESPACE}, \
DB %{MULTIPART_DATA_BEFORE}, \
DA %{MULTIPART_DATA_AFTER}, \
HF %{MULTIPART_HEADER_FOLDING}, \
LF %{MULTIPART_LF_LINE}, \
SM %{MULTIPART_MISSING_SEMICOLON}, \
IQ %{MULTIPART_INVALID_QUOTING}, \
IP %{MULTIPART_INVALID_PART}, \
IH %{MULTIPART_INVALID_HEADER_FOLDING}, \
FL %{MULTIPART_FILE_LIMIT_EXCEEDED}'"

# 我们是否看到任何可能是边界的内容？关于 ModSecurity Multipart 解析器的简短说明：如果所有"类边界"行与 MIME 头中给定的边界字符串匹配,则解析器返回值 0。在任何其他情况下,它都会返回不同的值,例如 1 或 2。
SecRule MULTIPART_UNMATCHED_BOUNDARY "@eq 1" \
    "id:'200004',phase:2,t:none,log,deny,msg:'Multipart parser detected a possible unmatched boundary.'"

# PCRE 调优 - 我们要避免潜在的正则表达式 DoS 条件
SecPcreMatchLimit 20000
SecPcreMatchLimitRecursion 20000

# 某些内部错误会在 TX 中设置标志,我们需要查找这些标志。所有这些都以"MSC_"为前缀。
SecRule TX:/^MSC_/ "!@streq 0" \
    "id:'200005',phase:2,t:none,log,deny,msg:'ModSecurity internal error flagged: %{MATCHED_VAR_NAME}'"


# -- 响应体处理 --------------------------------------------------

# 允许 ModSecurity 访问响应体。您应该启用此指令以识别错误和数据泄漏问题。请注意,启用此指令会增加内存消耗和响应延迟。
SecResponseBodyAccess On

# 您想检查哪些响应 MIME 类型？您应该调整下面的配置以捕获文档但避免静态文件(例如图像和存档)。
SecResponseBodyMimeType text/plain text/html text/xml

# 缓冲最大 512 KB 长度的响应体。
SecResponseBodyLimit 524288

# 当遇到大于配置限制的响应体时会发生什么？默认情况下,我们处理已有的内容并让其余部分通过。这在某种程度上不太安全,但不会破坏任何合法页面。
SecResponseBodyLimitAction ProcessPartial


# -- 文件系统配置 ------------------------------------------------

# ModSecurity 存储临时文件的位置(例如,当需要处理大于配置限制的文件上传时)。由于所有系统都有 /tmp 可用,因此选择了此默认设置,但这并不理想。建议您指定一个私有位置。
SecTmpDir /tmp/

# ModSecurity 将保持其持久数据的位置。由于所有系统都有 /tmp 可用,因此选择了此默认设置,但它也应该更新到其他用户无法访问的位置。
SecDataDir /tmp/


# -- 文件上传处理配置 -------------------------------------

# ModSecurity 存储拦截的上传文件的位置。此位置必须对 ModSecurity 是私有的。您不希望服务器上的其他用户访问这些文件,对吧？
#SecUploadDir /opt/modsecurity/var/upload/

# 默认情况下,仅保留被确定为异常的文件(通过外部检查脚本)。为此,您还需要至少一个文件检查规则。
#SecUploadKeepFiles RelevantOnly

# 上传的文件默认创建时的权限不允许任何其他用户访问它们。如果要将 ModSecurity 连接到外部程序(例如防病毒软件),可能需要放宽这一限制。
#SecUploadFileMode 0600


# -- 调试日志配置 -------------------------------------------------

# 默认调试日志配置是复制错误日志中的错误、警告和通知消息。
#SecDebugLog /opt/modsecurity/var/log/debug.log
#SecDebugLogLevel 3


# -- 审计日志配置 -------------------------------------------------

# 记录被规则标记的事务,以及触发服务器错误的事务(由 5xx 或 4xx 确定,不包括 404 级别响应状态码)。
SecAuditEngine RelevantOnly
SecAuditLogRelevantStatus "^(?:5|4(?!04))"

# 记录我们知道的关于事务的所有信息。
# SecAuditLogParts ABIJDEFHZ
SecAuditLogParts ABCDEFHZ


# 使用单个文件进行日志记录。这更容易查看,但假设您只会偶尔使用审计日志。
SecAuditLogType Serial
SecAuditLog /var/log/modsec_audit.log

# 指定并发审计日志记录的路径。
#SecAuditLogStorageDir /opt/modsecurity/var/audit/


# -- 其他配置 -----------------------------------------------------------

# 使用最常用的 application/x-www-form-urlencoded 参数分隔符。可能只有某处的一个应用程序使用其他分隔符,所以不要期望更改此值。
SecArgumentSeparator &

# 使用版本 0 (零) cookie,因为这是大多数应用程序使用的版本。使用不正确的 cookie 版本可能会使您的安装面临规避攻击(针对检查命名 cookie 的规则)。
SecCookieFormat 0

# 指定您的 Unicode 代码点。此映射由 t:urlDecodeUni 转换函数使用,以正确映射到您的语言的编码数据。正确设置这些指令有助于减少误报和漏报。
SecUnicodeMapFile unicode.mapping 20127

# 通过共享有关当前 ModSecurity 版本和依赖项版本的信息来提高 ModSecurity 的质量。注意：截至 2022 年 4 月,打开此设置不再有任何优势,因为没有活跃的信息接收者。
SecStatusEngine Off

# 包含 CRS 设置文件
include /usr/local/nginx/conf/modsecurity/crs-setup.conf

# 包含 CRS 规则文件
include /usr/local/nginx/conf/modsecurity/rules/*.conf

# 包含 自定义规则
include /usr/local/nginx/conf/modsecurity/custom-*.conf
# 包含 排除规则
include /usr/local/nginx/conf/modsecurity/exceptions/*.conf
